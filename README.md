# Лабораторная работа №6: Взаимодействие контейнеров

## Цель работы
Целью данной лабораторной работы является овладение навыками управления взаимодействием нескольких контейнеров. В результате выполнения работы я научился настраивать Docker-окружение для работы с контейнерами Nginx и php-fpm, обеспечивая корректную обработку PHP-запросов.

## Задание
Необходимо создать PHP-приложение на базе двух контейнеров: Nginx и php-fpm, настроив их взаимодействие через Docker-сеть. Для выполнения задания нужно создать репозиторий, настроить контейнеры, переопределить конфигурацию Nginx и проверить работоспособность веб-приложения.


## Выполнение

### Шаг 1: Создание репозитория и подготовка структуры проекта

1. Создал репозиторий `containers06` и склонировал его на свой компьютер.
2. В директории `containers06` создал директорию `mounts/site`, в которую переписал сайт на PHP, созданный ранее в рамках курса по PHP.

### Шаг 2: Создание файла .gitignore

Создал файл `.gitignore` в корне проекта и добавил строки, чтобы исключить из отслеживания содержимое директории `mounts/site`:

```plaintext
# Ignore files and directories
mounts/site/*
```

### Шаг 3: Создание конфигурационного файла Nginx

Создал файл `nginx/default.conf` со следующим содержимым для настройки веб-сервера:

```nginx
server {
    listen 80;
    server_name _;
    root /var/www/html;
    index index.php;
    location / {
        try_files $uri $uri/ /index.php?$args;
    }
    location ~ \.php$ {
        fastcgi_pass backend:9000;
        fastcgi_index index.php;
        fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
        include fastcgi_params;
    }
}
```

### Шаг 4: Создание сети для контейнеров

Создал сеть `internal` для контейнеров, чтобы они могли взаимодействовать друг с другом.

```bash
docker network create internal
```

### Шаг 5: Создание контейнера с php-fpm (backend)

Создал контейнер для обработки PHP-запросов с использованием образа `php:7.4-fpm`. Контейнер был настроен на работу в сети `internal`, а директория `mounts/site` была примонтирована в `/var/www/html`:

```bash
docker run -d \
  --name backend \
  --network internal \
  -v "D:\Работы Университет\containers06\mounts\site:/var/www/html" \
  php:7.4-fpm
```

### Шаг 6: Создание контейнера с Nginx (frontend)

Создал контейнер с веб-сервером Nginx на основе образа `nginx:1.23-alpine`. В контейнер был примонтирован файл конфигурации `nginx/default.conf` и директория `mounts/site`, а также был проброшен порт 80 контейнера на порт 80 хоста:

```bash
docker run -d \
  --name frontend \
  --network internal \
  -v "D:\Работы Университет\containers06\mounts\site:/var/www/html" \
  -v "D:\Работы Университет\containers06\nginx\default.conf:/etc/nginx/conf.d/default.conf" \
  -p 80:80 \
  nginx:1.23-alpine
```

### Шаг 7: Проверка работы сайта

Перешел в браузер и открыл страницу по адресу [http://localhost](http://localhost). После загрузки страницы с базовой информацией о сервере Nginx, обновил страницу, чтобы убедиться, что сайт работает корректно и отображает PHP-контент.

![Image](https://github.com/user-attachments/assets/b02a4f6d-63d7-4883-993d-a9ee41368351)

### Ответы на вопросы

1. **Каким образом в данном примере контейнеры могут взаимодействовать друг с другом?**

   Контейнеры взаимодействуют через созданную Docker-сеть `internal`. Контейнер с Nginx отправляет запросы на контейнер с php-fpm (backend) через адрес `backend:9000`, где `backend` — это имя контейнера, а `9000` — порт, на котором работает php-fpm.

2. **Как видят контейнеры друг друга в рамках сети internal?**

   В сети Docker контейнеры видят друг друга по именам, заданным при их запуске. В данном примере контейнер с Nginx может обращаться к контейнеру с php-fpm, используя имя контейнера `backend`, как адрес для отправки PHP-запросов.

3. **Почему необходимо было переопределять конфигурацию nginx?**

   Переопределение конфигурации Nginx было необходимо для правильной обработки PHP-запросов. По умолчанию Nginx не настроен для работы с php-fpm, поэтому в конфигурации было указано, что запросы PHP должны обрабатываться через `fastcgi_pass backend:9000`, где `backend` — это имя контейнера с php-fpm, а `9000` — порт для передачи PHP-запросов.

## Выводы

- Я создал два контейнера — для веб-сервера Nginx и для php-fpm, настроив их для совместной работы через сеть Docker.
- Были выполнены необходимые шаги для настройки правильной обработки PHP-запросов в конфигурации Nginx.
- Все этапы работы были успешно выполнены, сайт был протестирован и работал корректно.

